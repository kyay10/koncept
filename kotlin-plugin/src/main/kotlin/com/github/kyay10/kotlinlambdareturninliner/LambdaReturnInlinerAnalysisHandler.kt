package com.github.kyay10.kotlinlambdareturninliner

import org.jetbrains.kotlin.analyzer.AnalysisResult
import org.jetbrains.kotlin.builtins.isFunctionTypeOrSubtype
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.com.intellij.openapi.project.Project
import org.jetbrains.kotlin.com.intellij.openapi.util.TextRange
import org.jetbrains.kotlin.com.intellij.openapi.vfs.VirtualFile
import org.jetbrains.kotlin.com.intellij.openapi.vfs.impl.jar.CoreJarFileSystem
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.com.intellij.psi.PsiFileFactory
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.config.JVMConfigurationKeys
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.idea.KotlinLanguage
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.psi.psiUtil.parentsWithSelf
import org.jetbrains.kotlin.resolve.BindingTrace
import org.jetbrains.kotlin.resolve.jvm.extensions.AnalysisHandlerExtension
import org.jetbrains.kotlin.resolve.multiplatform.isCommonSource
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DescriptorWithContainerSource
import org.jetbrains.kotlin.types.isFlexible
import org.jetbrains.kotlin.types.typeUtil.isTypeParameter
import org.jetbrains.org.objectweb.asm.Opcodes
import java.io.File

const val GENERATED_FOLDER = "kotlinLambdaReturnInliner"
const val GENERATED_FOLDER_WITH_DOT = ".$GENERATED_FOLDER"

open class KtRecursiveVisitorVoid : KtVisitorVoid() {
  override fun visitKtElement(element: KtElement) {
    super.visitKtElement(element)
    element.acceptChildrenVoid(this)
  }
}

class LambdaReturnInlinerAnalysisHandler(
  val messageCollector: MessageCollector,
  private val configuration: CompilerConfiguration,
  private val generatedSourcesDir: File?,
) :
  AnalysisHandlerExtension {
  private var hasRun = false
  lateinit var allPossibleKtSources: List<VirtualFile>
  val fileToKtFileDeclarations: MutableMap<VirtualFile, KtFileDeclarations> = mutableMapOf()

  @OptIn(ExperimentalStdlibApi::class)
  override fun analysisCompleted(
    project: Project,
    module: ModuleDescriptor,
    bindingTrace: BindingTrace,
    files: Collection<KtFile>
  ): AnalysisResult? = withBindingContext(bindingTrace.bindingContext){
    if (!::allPossibleKtSources.isInitialized) {
      allPossibleKtSources = buildList {
        configuration[JVMConfigurationKeys.MODULES]?.forEach { jvmModule ->
          val fs = CoreJarFileSystem()
          jvmModule.getClasspathRoots()
            .mapNotNull { classpathRoot -> File(classpathRoot).takeIf { it.extension == "jar" } }
            .flatMap { jar ->
              jar.parentFile.parentFile.collectFiles().filter { it.extension == "jar" }
                .mapNotNull { fs.findFileByPath("${it.absolutePath}!/") }
            }.forEach { virtualJarFile ->
              val collectedFiles = virtualJarFile.collectFiles()
              addAll(collectedFiles.filter { it.extension == "kt" })
            }
        }
      }
    }
    if (hasRun) return null
    hasRun = true
    // Fallback: looks through all the non-common kt source files and chooses the one that wasn't generated by us.
    // TODO: maybe figure out a way to use this to find other generated files?
    //  Perhaps by looking for build/generated/source and piggybacking off of that directory for our purposes
    val sourceRoot = generatedSourcesDir ?: files.filter { it.isCommonSource != true }.map { File(it.virtualFilePath) }
      .first { it.parentFile.name != GENERATED_FOLDER_WITH_DOT }.parentFile.resolve(
        GENERATED_FOLDER_WITH_DOT
      )
    sourceRoot.apply {
      mkdirs()
      // Start off with a clean slate
      this.listFiles()?.forEach { it.delete() }
    }
    files.forEach { ktFile ->
      ktFile.acceptChildrenVoid(object : KtRecursiveVisitorVoid() {
        override fun visitCallExpression(expression: KtCallExpression) {
          super.visitCallExpression(expression)
          val resolvedCall = expression.resolvedCall
          val resolvedDescriptor = resolvedCall?.resultingDescriptor
          // This is the same criteria that the IrExtension has for inlining
          if (resolvedDescriptor?.safeAs<FunctionDescriptor>()?.isInline != true
            || (!(resolvedCall.valueArguments.any { (key, value) ->
              (value.arguments.any {
                it is KtLambdaArgument || it.getArgumentExpression()
                  ?.typeThroughResolvingCall?.isFunctionTypeOrSubtype == true
              } || key.declaresDefaultValue()) && ((key.type.isMarkedNullable && key.type.isFunctionTypeOrSubtype) || key.type.isFlexible() || key.type.isTypeParameter() || key.original.type.isFlexible()) || key.original.type.isTypeParameter()
            })
              && !(listOfNotNull(
              resolvedDescriptor.dispatchReceiverParameter toNotNull resolvedCall.dispatchReceiver,
              resolvedDescriptor.extensionReceiverParameter toNotNull resolvedCall.extensionReceiver
            ).any { (key, value) -> value.type.isFunctionTypeOrSubtype && ((key.type.isFunctionTypeOrSubtype) || key.type.isFlexible()) })
              )
          ) {
            return
          }
          val reader =
            resolvedDescriptor.safeAs<DescriptorWithContainerSource>()?.containerSource?.safeAs<JvmPackagePartSource>()?.knownJvmBinaryClass?.location?.let { it1 ->
              CoreJarFileSystem().findFileByPath(
                it1
              )
            }?.contentsToByteArray()?.let { org.objectweb.asm.ClassReader(it) }
          val source = run {
            var result: String? = null
            try {
              reader?.accept(object : org.objectweb.asm.ClassVisitor(Opcodes.API_VERSION) {
                override fun visitSource(source: String?, debug: String?) {
                  super.visitSource(source, debug)
                  result = source
                  throw EmptyThrowable // Purposeful optimization to not go through the rest of the class's data
                }
              }, 0)
            } catch (e: EmptyThrowable) {
              /* Purposefully ignored */
            }
            result
          }
          val possibleReferredFiles = allPossibleKtSources.filter { it.name == source }
          for (file in possibleReferredFiles) {
            // Collect the declarations for each unique file only once
            val ktFileDeclarations = fileToKtFileDeclarations.getOrPut(file) {
              KtFileDeclarations(file.inputStream.readAllBytes().decodeToString(), project).apply {
                this.ktFile.acceptChildrenVoid(object : KtRecursiveVisitorVoid() {
                  override fun visitDeclaration(dcl: KtDeclaration) {
                    super.visitDeclaration(dcl)
                    declarations.add(dcl)
                  }
                })
              }
            }
            // TODO: member inline functions should be changed to @HidesMembers extension inline functions
            //  but be careful of needing to specify generics though
            ktFileDeclarations.declarations.forEach { function ->
              if (function is KtNamedFunction && function.hasModifier(KtTokens.INLINE_KEYWORD) && function.nameAsName == resolvedDescriptor.name && function.valueParameters.map { it.nameAsName } == resolvedDescriptor.valueParameters.map { it.name }) {
                ktFileDeclarations.declarationsToKeep.addAll(function.parentsWithSelf.toList())
              }
            }
          }
        }
      })
    }
    for ((file, ktFileDeclarations) in fileToKtFileDeclarations) {
      var text: String = ktFileDeclarations.text
      ktFileDeclarations.declarations.removeAll(ktFileDeclarations.declarationsToKeep)
      // Just don't overthink this one too much. We're keeping any declaration inside of a function just in
      // case instead of focusing on the specific inline declarations. That's because of (probably) captured
      // variables that can be used in the future in maybe local inline funs (if that ever gets supported), but
      // again just don't overthink it ;)
      val functionDeclarations = ktFileDeclarations.declarationsToKeep.filterIsInstance<KtNamedFunction>()
      val textRanges = ktFileDeclarations.declarations.map { it.textRange }
      val deletedRanges = mutableListOf<TextRange>()
      // Ensure that we only delete unique ranges, and so any nested ones shall just bubble up to their parent
      deletedRanges.addAll(textRanges.filterNot { range ->
        textRanges.any {
          it != range && it.contains(
            range
          )
        } ||
          functionDeclarations.any {
            it.textRange != range && it.textRange.contains(
              range
            )
          }
      })
      var shiftLeft = 0
      // We're deleting the text ranges from start to end of the file because it's simpler to do by just shifting
      // the offsets as we go along, and so let's sort the ranges that we need to delete from first to last in file
      for (range in deletedRanges.sortedBy { it.startOffset }) {
        text = text.removeRange(range.startOffset - shiftLeft, range.endOffset - shiftLeft)
        shiftLeft += range.length
      }
      // Suppress all the possible errors that you can ever imagine. These shadowed files will end up being deleted in
      // IR so there's no need to worry about them
      text =
        """@file:Suppress("EXPERIMENTAL_API_USAGE", "EXPERIMENTAL_API_USAGE_ERROR", "INVISIBLE_MEMBER", "INVISIBLE_REFERENCE", "CANNOT_OVERRIDE_INVISIBLE_MEMBER", "INVISIBLE_SETTER", "REDECLARATION", "PACKAGE_OR_CLASSIFIER_REDECLARATION", ) ${"\n $text"}"""
      // Generate a "unique" filename based on this source file's path in the jar
      // TODO: make this safe for expect/actual sources. In fact, make sure to handle any actual declarations that sneak
      //  in the generated shadowed file (perhaps with a simple suppress)
      val newFileName = file.path.substringAfterLast("!/").replace("/", "_")
      val newFile = sourceRoot.resolve(newFileName).apply { createNewFile() }
      newFile.writeText(text)
    }
    return AnalysisResult.RetryWithAdditionalRoots(bindingTrace.bindingContext, module, listOf(), listOf(sourceRoot))
  }
}

object EmptyThrowable : Throwable() {
  override fun fillInStackTrace(): Throwable = this
}

data class KtFileDeclarations(
  val text: String,
  val ktFile: KtFile,
  val declarations: MutableList<KtDeclaration> = mutableListOf(),
  val declarationsToKeep: MutableList<PsiElement> = mutableListOf()
) {
  constructor(
    text: String,
    project: Project,
    declarations: MutableList<KtDeclaration> = mutableListOf(),
    declarationsToKeep: MutableList<PsiElement> = mutableListOf()
  ) : this(
    text, PsiFileFactory.getInstance(project)
      .createFileFromText(KotlinLanguage.INSTANCE, text) as KtFile, declarations, declarationsToKeep
  )
}

fun KtElement.acceptChildrenVoid(ktVisitorVoid: KtVisitorVoid) {
  acceptChildren(ktVisitorVoid, null)
}
